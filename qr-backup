#!/usr/bin/env python3
"""
Takes a binary file, and outputs a "paper backup": a printable pdf full of QR codes. 

Following the directions in the pdf, the QR codes can be re-scanned or photographed using a webcame to restore the original file.

Requirements to make the PDF: python 'qrcode' library, imagemagick, img2pdf
Requirements to restore from the PDF: zbar (only)
"""
import PIL, PIL.Image, PIL.ImageDraw, PIL.ImageFont, PIL.ImageOps
import base64, datetime, gzip, hashlib, io, logging, math, os, reedsolo, subprocess, sys, qrcode
assert sys.version_info >= (3,6), "Python 3.6 is required. Submit a patch removing f-strings to fix it, sucka!"

HELP='''Usage: qr-codes.py [OPTIONS] FILE
               qr-codes.py --restore [OPTIONS]
               qr-codes.py --restore [OPTIONS] IMAGE [IMAGE ...]
Convert a binary file to a paper .pdf backup of QR codes. With '--restore', read the QR codes in the paper backup using a webcam or scanner, to re-create the original file.

Restore directions are included in the PDF, and do not require qr-backup. Make sure to test that you can actually read the QR size you select.

Backup options:
    --dpi DPI
        Sets the print resolution of your printer. Default: 600
    --compress, --no-compress
        This gives a more compact backup, but partial recovery is impossible. Default: compressed
    --erasure-coding, --no-erasure coding
        Add QR codes in case you lose any. Only works with --restore. Always at 30% loss allowed. Default: on
    --error-correction CORRECTION
        Sets the error correction level. Options are L, M, Q, and H. Default: M (25%)
    --filename FILENAME
        Set the restored filename. Max 32 chars. Default: same as <FILE>
    --output FILENAME, -o FILENAME
        Set the output pdf path (redirecting stdout also works). Default: <FILE>.qr.pdf
    --page WIDTH_POINTS HEIGHT_POINTS
        Sets the usable size of the paper on your printer. This should NOT be 8.5 x 11 -- make sure to include margins. Default: 500x600
    --qr-version VERSION
        Uses QR codes, version VERSION. Versions range from 1-40. The bigger the version, the harder to scan but the more data per code. Default: 10
    --scale SCALE
        Scale QR codes so that each small square in the QR code is SCALE x SCALE pixels. Default: 8

Restore options:
    --code-count COUNT, -c COUNT
        Specify the number of total QR codes. Default: automatic
    --compress, --no-compress
        Force decompression (on/off). Default: automatic
    --erasure-coding, --no-erasure coding
        Use extra QR codes to restore. Default: automatic
    --image-restore
        Force image-based (scanner) restore. Default: automatic
    --display, --no-display
        For webcam scanning, (display/don't display) a webcam preview. Default: display
    --output FILENAME, -o
        Set the restore file path. Default: stdout
    --sha256 SHA256
        Include a sha256sum to check the file. Default: no check, prints checksum
    --webcam-restore
        Force webcam-based restore. Default: automatic

Options for both:
    --verbose, -v
        Print more detailed information during run

The QR mode is always binary with no QR compression.'''

L = qrcode.constants.ERROR_CORRECT_L
M = qrcode.constants.ERROR_CORRECT_M # default, 25%
Q = qrcode.constants.ERROR_CORRECT_Q
H = qrcode.constants.ERROR_CORRECT_H
MODE = qrcode.util.MODE_8BIT_BYTE # not settable

VERSIONS = {
    # Binary bytes for each version size, 1-40
    # Source: qrcode.com (DENSO WAVE)
    # Order is L,M,Q,H on right
    1: [17,14,11,7],
    2: [32,26,20,14],
    3: [53,42,32,24],
    4: [78,62,46,34],
    5: [106,84,60,44],
    6: [134,106,74,58],
    7: [154,122,86,64],
    8: [192,152,108,84],
    9: [230,180,130,98],
    10: [271,213,151,119],
    11: [321,251,177,137],
    12: [367,287,203,155],
    13: [425,331,241,177],
    14: [458,362,258,194],
    15: [520,412,292,220],
    16: [586,450,322,250],
    17: [644,504,364,280],
    18: [718,560,394,310],
    19: [792,624,442,338],
    20: [858,666,482,382],
    21: [929,711,509,403],
    22: [1003,779,565,439],
    23: [1091,857,611,461],
    24: [1171,911,661,511],
    25: [1273,997,715,535],
    26: [1367,1059,751,593],
    27: [1465,1125,805,625],
    28: [1528,1190,868,658],
    29: [1628,1264,908,698],
    30: [1732,1370,982,742],
    31: [1840,1452,1030,790],
    32: [1952,1538,1112,842],
    33: [2068,1628,1168,898],
    34: [2188,1722,1228,958],
    35: [2303,1809,1283,983],
    36: [2431,1911,1351,1051],
    37: [2563,1989,1423,1093],
    38: [2699,2099,1499,1139],
    39: [2809,2213,1579,1219],
    40: [2953,2331,1663,1273],
}
VERSION_TO_BYTES = {
    quality: {version: sizes[place] for version, sizes in VERSIONS.items()} for place, quality in enumerate([L,M,Q,H])
}

def grid_size(version):
    return version*4+17

def generate_erasure(data, chunk_size, erasure_count):
    # Pad data to even chunk_size
    padding_len = (chunk_size - len(data)) % chunk_size
    data_padded = data + b"\n"*padding_len # pad with newlines--see bottom of restore_erasure for why
    num_chunks = len(data_padded) // chunk_size

    codec = reedsolo.RSCodec(erasure_count)
    # Split data into NUM_CHUNKS length strings
    sample = codec.encode(data_padded[::chunk_size])
    symbols = [bytes(a) for a in zip(*(codec.encode(data_padded[i::chunk_size]) for i in range(chunk_size)))]
    assert len(symbols) != 0
    assert all(len(symbol)==chunk_size for symbol in symbols)

    erasure_codes = symbols[-erasure_count:]
    assert len(erasure_codes) == erasure_count

    num_erased = erasure_count
    self_check = restore_erasure([None]*num_erased+[data[i*chunk_size:i*chunk_size+chunk_size] for i in range(num_erased, num_chunks)], erasure_codes, chunk_size)
    assert self_check == data, "Self-check failed in generate_erasure"
    logging.info("generate_erasure: deleted first few symbols, restore works fine")
    return erasure_codes

def restore_erasure(normal_codes, erasure_codes, chunk_size):
    """
    Restores a file using erasure codes. Missing symbols should be supplied as None.
    """
    # Make 'symbols' uniform length bytestrings, while extracting missing_symbols
    symbols = normal_codes + erasure_codes
    missing_symbols = [i for i,symbol in enumerate(symbols) if symbol is None]
    for i in missing_symbols:
        symbols[i] = b' '*chunk_size # Doesn't really matter what we set this to as long as it's the right length.
    assert all(isinstance(symbol, bytes) for symbol in symbols)

    # Pad normal_codes[-1] to even chunk_size
    i = len(normal_codes)-1
    if len(symbols[i]) < chunk_size:
        padding_len = chunk_size-len(symbols[i])
        symbols[i] = symbols[i] + b"\n"*padding_len # pad with newlines--see bottom of restore_erasure for why
        assert len(symbols[i]) == chunk_size
    assert all(len(symbol)==chunk_size for symbol in symbols)

    # Decode
    codec = reedsolo.RSCodec(len(erasure_codes))
    broken_strings = list(zip(*symbols))
    fixed_strings = [codec.decode(x, erase_pos=missing_symbols)[0] for x in broken_strings]
    simple_restore = b''.join(bytes(x) for x in zip(*fixed_strings))
    assert len(simple_restore) == len(normal_codes)*chunk_size
    return simple_restore.rstrip(b'\n') # remove padding. newlines were used so this works--they're guaranteed not to appear in the original data. alternative would be to store the data length

def generate_chunks(data, naive_chunk_size, use_erasure_coding, erasure_rate=0.3):
    """
    Return a bunch of chunks to put in QRs.
    Sadly erasure coding means we need to do base64 encoding at the per-QR level, and always (at least until we add a direct binary scan, in which case we can stop doing it at all)
    """
    num_normal, num_erasures, num_qrs = 0, 0, 0
    for chunk_digits in range(1, 10):
        prefix_format = "{}{:0>" + str(chunk_digits) + "}/{:0>" + str(chunk_digits)+"} "
        chunk_size_chars = naive_chunk_size - len(prefix_format.format('N',0,0))
        chunk_size_bytes = chunk_size_chars*6//8
        num_normal = math.ceil(len(data) / chunk_size_bytes)
        if use_erasure_coding:
            num_erasures = math.ceil(num_normal/(1-erasure_rate))-num_normal
        else:
            num_erasures = 0
        num_qrs = num_normal+num_erasures
        if num_normal <= 10**chunk_digits-1:
            break
    assert math.ceil(len(data)/chunk_size_bytes) == num_normal <= 10**chunk_digits-1

    chunks = []
    for i, start in enumerate(range(0, len(data), chunk_size_bytes)):
        chunks.append(('N', i, data[start:start+chunk_size_bytes]))
    assert len(chunks) == num_normal
    
    if use_erasure_coding:
        for i, chunk in enumerate(generate_erasure(data, chunk_size_bytes, num_erasures)):
            chunks.append(('E', i, chunk))
    assert len(chunks) == num_qrs

    chunks = [(prefix_format.format(piece_type, i+1, num_normal), piece) for piece_type, i, piece in chunks]
    chunks = [(label, label.encode('ascii')+base64.b64encode(piece)) for label, piece in chunks]
    assert len(chunks) == num_qrs
    return chunks, chunk_digits

def qr_codes(data, error_correction, version, scale, use_erasure_coding):
    qrs = []
    qr_bytes = VERSION_TO_BYTES[error_correction][version]
    chunks, chunk_digits = generate_chunks(data, qr_bytes, use_erasure_coding)
    for label, chunk in chunks:
        qr = qrcode.QRCode(
            version=version,
            error_correction=error_correction,
            box_size=scale,
        )
        qr.add_data(qrcode.util.QRData(chunk, mode=MODE), optimize=0)
        qr.make(fit=False)
        qrs.append((label, qr))
    label_length = len(qrs[0][0])
    assert all(len(qr[0])==label_length for qr in qrs)
    return label_length, qrs

def show_help(error=None):
    if error:
        print(HELP, file=sys.stderr)
        print(file=sys.stderr)
        print("ERROR: {}".format(error), file=sys.stderr)
        sys.exit(1)
    else:
        print(HELP)
        sys.exit(0)

def add_label(image, text, side="bottom", max_fontsize=24, max_width=None, label=None):
    """
    Add a label. The fontsize is max_fontsize if possible, otherwise it's shrunk down.
    The label is aligned to the bounding box of the image (lines up with margins).
    """
    # Figure out the size and position of the original image
    bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()
    if bbox is None:
        left, upper, right, lower = 0,0,0,0
        if max_width is None:
            max_width = image.size[0]
    elif max_width is None:
        left, upper, right, lower = bbox
        max_width = right-left
    else:
        left, upper, right, lower = bbox
        right, max_width = max(right, max_width), max_width-left

    # Generate a label that fits. The fontsize will be reduced if needed. No word wrap is performed.
    if label is None:
        label = generate_label(text, max_width=max_width, max_fontsize=max_fontsize)
    else:
        assert label.size[0] <= max_width, "Premade label is too wide"
    label_bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()

    # Layout
    width, combined_height = max(image.size[0], left+label.size[0]), image.size[1] + label.size[1]
    labeled = PIL.Image.new(mode="1", size=(width, combined_height), color=1) #B+W
    if side == "bottom":
        labeled.paste(image, (0,0))
        labeled.paste(label, (left,image.size[1]))
    elif side == "top":
        labeled.paste(label, (left,0))
        labeled.paste(image, (0,label.size[1]))
    else:
        assert False, "Unknown side for label: {}".format(side)
    return labeled

def generate_label(text, max_width, max_fontsize=24):
    # to do, maybe some fancy word wrap
    test_im = PIL.Image.new(mode="1", size=(1,1), color=1)
    test_draw = PIL.ImageDraw.Draw(test_im)

    for fontsize in range(max_fontsize, 3, -1):
        font = PIL.ImageFont.truetype("DejaVuSans.ttf", fontsize)
        width, height = test_draw.multiline_textsize(text, font=font)
        height += 4
        if width <= max_width:
            #logging.info("Printing label at font size " + str(fontsize))
            im = PIL.Image.new(mode="1", size=(width, height), color=1) # black-and-white
            draw = PIL.ImageDraw.Draw(im)
            draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
            return im
    #assert False
    logging.error("Label cannot fit in the requested width. Forcing output...")
    font = PIL.ImageFont.truetype("DejaVuSans.ttf", 12)
    im = PIL.Image.new(mode="1", size=bbox, color=1) # black-and-white
    draw = PIL.ImageDraw.Draw(im)
    draw.multiline_text((0,0), text)
    return im

def h_merge(images):
    # Alignment is top-aligned
    combined_width = sum(image.size[0] for image in images)
    max_height = max(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(combined_width, max_height), color=1) #B+W
    width = 0
    for source_image in images:
        im.paste(source_image,(width, 0))
        width += source_image.size[0]
    return im

def v_merge(images):
    # Alignment is left-aligned
    max_width = max(image.size[0] for image in images)
    combined_height = sum(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(max_width, combined_height), color=1) #B+W
    height = 0
    for source_image in images:
        im.paste(source_image,(0, height))
        height += source_image.size[1]
    return im

def main_backup(args):
    # default settings
    qr_version = 10
    error_correction = qrcode.constants.ERROR_CORRECT_M # default, 25%
    scale = 8
    dpi = 300
    page_w_points, page_h_points = 500,600
    restore_file = None
    use_compression = True
    use_erasure_coding = True
    output_path = None
    GENERATE_DOCS = False # Manually generate example.png for the README when qr-backup changes

    # parse arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--compress":
            use_compression = True
        elif arg == "--dpi":
            if len(args) < 1:
                show_help("--dpi requires one argument (an integer dots-per-inch)")
            dpi, args = int(args[0]), args[1:]
        elif arg == "--erasure-coding":
            use_erasure_coding = True
        elif arg == "--error-correction":
            if len(args) < 1:
                show_help("--error-correction requires one of: L M Q H")
            error_correction, args = {"L":L, "M": M, "Q": Q, "H": H}[args[0].upper()], args[1:]
        elif arg == "--filename":
            if len(args) < 1:
                show_help("--filename requires one argument")
            restore_file, args = args[0], args[1:]
            assert len(restore_file) > 0 and not restore_file.startswith("-")
        elif arg == "--generate-docs": # Development only. Don't document or use please.
            GENERATE_DOCS=True
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-erasure-coding":
            use_erasure_coding = False
        elif arg == "--page":
            if len(args) < 2:
                show_help("--page requires two arguments (decimal page width and height in inches)")
            page_w_points, page_h_points, args = float(args[0]), float(args[1]), args[2:]
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--qr-version":
            if len(args) < 1:
                show_help("--qr-version requires one argument (integer version between 2 and 40)")
            qr_version, args = int(args[0]), args[1:]
        elif arg == "--scale":
            if len(args) == 0:
                show_help("--scale requires one argument (integer scale in pixels)")
            scale, args = int(args[0]), args[1:]
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)
    if len(pargs) < 1:
        show_help("Please supply a filename to backup")
    elif len(pargs) > 1:
        show_help("Multiple filenames given. qr-backup can only back up one file at a time")
    input_path, = pargs

    use_stdout = (output_path is None) and not sys.stdout.isatty()
    use_stdin = (input_path == "-")
    if restore_file is None:
        input_filename = input_path.split("/")[-1]
        if not use_stdin and len(input_filename) <= 32:
            restore_file = input_filename
        else:
            restore_file = "file"
    if output_path is None:
        if use_stdin:
            output_path = f"{restore_file or 'stdin'}.qr.pdf"
        else:
            output_path = input_path+".qr.pdf"

    nice_cmd = ' '.join([x for x in ["qr-backup", "--qr-version", str(qr_version), "--dpi", str(dpi), "--scale", str(scale), "--error-correction", "LMQH"[error_correction], "--page", str(page_w_points), str(page_h_points), '--compress' if use_compression else '--no-compress', "--erasure-coding" if use_erasure_coding else "--no-erasure-coding", "--filename", restore_file] if x is not None])
    backup_date = datetime.date.today().strftime("%Y-%m-%d")
    logging.info("Original arguments were: {}".format(repr(args)))
    logging.info("Command arguments parsed. Equivalent command: {}".format(nice_cmd))

    # open the file (or stdin, if "-" is passed as the file)
    if use_stdin:
        f = sys.stdin.buffer
    else:
        f = open(input_path, "rb")

    # read the entire file into memory
    try:
        content = f.read()
    finally:
        f.close()
    sha256sum = hashlib.sha256(content).hexdigest()
    original_len = len(content)
    logging.info(f"read file {restore_file} (sha {sha256sum}, {original_len/1000}KB)")

    # (Gzip) Compression
    if use_compression:
        content = gzip.compress(content)

    # Generate QR codes
    label_length, qrs = qr_codes(content, error_correction=error_correction, version=qr_version, scale=scale, use_erasure_coding=use_erasure_coding)

    # How to restore
    restore_cmd = f'sort -u | grep "^N" | cut -c{label_length+1}- | base64 -d'
    if use_compression:
        restore_cmd += ' | gunzip'
    logging.info(f"Restore command is: {restore_cmd}")

    # Instructions depend on the command line options, and the content of the file
    HOWTO = f'This is a paper backup of a computer file called: {restore_file}'
    HOWTO += '\nTo restore this file using qr-backup:'
    HOWTO += f'\n  Step 1 (webcam): qr-backup --restore'
    HOWTO += f'\n  Step 1 (scanner): qr-backup --restore IMAGE1 IMAGE2 ...'
    HOWTO += '\nTo restore this file from the command line in Linux:'
    HOWTO += f'\n  Step 1 (webcam option): zbarcam --raw | tee -a /tmp/qrs | cut -c1-{label_length+1} # Scan each code at least once in any order'
    HOWTO += f'\n  Step 1 (scanner option): zbarimg -q --raw *.png >>/tmp/qrs'
    howto_restore_cmd = restore_cmd.replace("sort -u", "sort -u /tmp/qrs")
    HOWTO += f'\n  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
    HOWTO += f'\n  Step 3 (verify): sha256sum {restore_file} # {sha256sum}'
    HOWTO += f'\nThis backup was generated on {backup_date} with: {nice_cmd}'

    # Calculate QR padding produced by qrcode module
    example_qr = qrs[0][1].make_image().copy()
    qr_bbox = PIL.ImageOps.invert(example_qr.copy().convert("L")).getbbox()
    qr_lpad, qr_tpad, qr_rpad, qr_bpad = qr_bbox[0], qr_bbox[1], example_qr.size[0]-qr_bbox[2], example_qr.size[1]-qr_bbox[3]
    qr_hpad, qr_vpad = qr_lpad + qr_rpad, qr_tpad + qr_bpad

    # Output QR codes with labels to Pillow Image objects
    labeled = []
    for i, (qr_label, qr) in enumerate(qrs):
        img = qr.make_image()
        label = f"code {qr_label} {restore_file}"
        labeled.append(add_label(img, label))
    logging.info(f"{len(qrs)} qr codes (at version {qr_version}) total")

    # Figure out page layout now that we know the size and number of QR codes. Output to the user.
    qr_w_pixel, qr_h_pixel = labeled[0].size
    logging.info(f"QR code (including label) is: {qr_w_pixel}x{qr_w_pixel}px")

    page_w_pixel, page_h_pixel = math.floor(page_w_points/72.0*dpi), math.floor(page_h_points/72.0*dpi) # 1 "dot" = 1 pixel. !!important note, DPI is not used yet, which is probably some config bug in Pillow
    logging.info(f"Page is: {page_w_pixel}x{page_h_pixel}px")

    howto_label = generate_label(HOWTO, page_w_pixel - qr_hpad)
    howto_height = howto_label.size[1]
    
    page_w_qr, page_h_qr = math.floor((page_w_pixel-2) // qr_w_pixel), math.floor((page_h_pixel-2-howto_height) // qr_h_pixel)
    qr_per_page = page_w_qr * page_h_qr
    if qr_per_page == 0:
        logging.error("Not even 1 QR fits on the given page. Forcing output anyway...")
        page_w_qr, page_h_qr, qr_per_page = 1,1,1
    num_pages = math.ceil(len(qrs)/qr_per_page)
    logging.info(f"{page_w_qr} x {page_h_qr} qr codes (at version {qr_version}) per page. {num_pages} pages total")

    density = original_len / num_pages
    logging.info(f"{len(content)} bytes in {num_pages} ({density/1000:.2f}KB/page)")

    # Combine rows
    rows = []
    for row_start in range(0, len(qrs), page_w_qr):
        row_qrs = labeled[row_start:row_start+page_w_qr]
        rows.append(h_merge(row_qrs))

    # Use imagemagick to make one png file per page-side
    unnumbered_pages = []
    for page_num, page_start in enumerate(range(0, len(rows), page_h_qr)):
        page_rows = rows[page_start:page_start+page_h_qr]
        page_qrs = v_merge(page_rows)
        page_complete = add_label(page_qrs, HOWTO, side="top", max_fontsize=24, max_width=page_w_pixel-2)

        if GENERATE_DOCS:
            page_h_pixel = page_complete.size[1]+2
        page = PIL.Image.new(mode="1", size=(page_w_pixel, page_h_pixel), color=1)
        page_draw = PIL.ImageDraw.Draw(page)
        page_draw.rectangle(((0,0), (page_w_pixel-1, page_h_pixel-1)), outline=0, fill=1, width=1) # Rectangle for debugging print cutoff, and to look nice.
        page.paste(page_complete, (1,1)) # Main contents
        unnumbered_pages.append(page)

    # Add page numbers after. Currently page-numbering is perfectly reliable, but we're about to add more complicated layout options.
    pages = []
    num_pages = len(unnumbered_pages)
    for page_num, page in enumerate(unnumbered_pages):
        page_num = generate_label("page {}/{}".format(page_num+1, num_pages), max_width=example_qr.size[0]/2)
        page.paste(page_num, (page.size[0]-page_num.size[0]-1-qr_rpad, page.size[1]-page_num.size[1]-11)) # Page num in bottom-right
        pages.append(page)

    if use_stdout: 
        # Write PDF to stdout
        # PIL's pdf writer needs to mmap, so it can't accept sys.stdout directly
        tmp_pdf = io.BytesIO() 
        pages[0].save(tmp_pdf, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}")
        sys.stdout.buffer.write(tmp_pdf.getbuffer())
    else:
        # Write PDF to file
        pages[0].save(output_path, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}")

    if use_stdout or use_stdin:
        # Can't test restore yet
        logging.warning("Automatic digital restore skipped because qr-backup is being used in a pipe.")
    else:
        # Test restore
        zbarimg_present = subprocess.call(["which", "zbarimg"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0

        if zbarimg_present:
            linux_test_command = "zbarimg --raw -q -Sdisable -Sqrcode.enable {} | {} | cmp {}".format(output_path, restore_cmd, input_path)
            logging.info("Performing linux CLI restore check: " + linux_test_command)
            linux_success = (subprocess.call(linux_test_command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, output_path]
            logging.info("Performing qr-backup restore check..." + ' '.join(self_test_command))
            self_test_success = (subprocess.call(self_test_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)

            if linux_success and self_test_success:
                logging.info("Automatic digital restore verification succeeded.")
            elif not linux_success:
                logging.error("!!Automatic digital restore verification FAILED (linux CLI). This indicates a bug in either zbarimg (more likely) or in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
                #sys.exit(1)
            else:
                logging.error("!!Automatic digital restore verification FAILED (qr-restore). This indicates a bug in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
                #sys.exit(1)
        else:
                logging.warning("Attempted digital restore verification, but zbarimg was not available")

    if GENERATE_DOCS:
        pages[0].save("docs/example.png")
        with open("docs/USAGE.md", "w") as f:
            f.write("Output of `qr-backup --help`:\n")
            f.write("\n")
            f.write("```\n")
            f.write(HELP)
            f.write("\n")
            f.write("```\n")

def image_restore(image_paths):
    # Special note: image_paths can include "-", in which case zbarimg will magically do the right thing
    zbarimg_present = subprocess.call(["which", "zbarimg"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0
    if not zbarimg_present:
        logging.fatal("zbarimg not present. install 'zbar' to scan files.")
        sys.exit(2)

    scan_command = ["zbarimg", "--raw", "-q", "-Sdisable", "-Sqrcode.enable"] + image_paths
    result = subprocess.run(scan_command, capture_output=True)
    for line in result.stdout.split(b"\n"):
        if line != b'':
            yield line

def webcam_restore(use_display):
    zbarimg_present = subprocess.call(["which", "zbarcam"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0
    if not zbarimg_present:
        logging.fatal("zbarcam not present. install 'zbar' to scan using your camera.")
        sys.exit(2)

    scan_command = ["zbarcam", "--raw", "-Sdisable", "-Sqrcode.enable"]
    if not use_display:
        scan_command.append("--nodisplay")

    with subprocess.Popen(scan_command, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL) as proc:
        while True:
            line = proc.stdout.readline()
            if line == b'':
                return
            if (yield line):
                return

def expected_codes(code_count, erasure_rate=0.3): # Returns a list of binary strings
    code_digits = math.ceil(math.log(code_count+1,10))
    num_erasures = math.ceil(code_count/(1-erasure_rate))-code_count
    expected_normal = [f"N{i:>0{code_digits}}" for i in range(1, code_count+1)]
    expected_erasure = [f"E{i:>0{code_digits}}" for i in range(1, num_erasures+1)]
    return [x.encode('ascii') for x in expected_normal+expected_erasure]
def restore_status(codes, code_count):
    if code_count is None:
        return f"{len(codes)}/??? codes read"
    else:
        missing = [x.decode('ascii') for x in expected_codes(code_count) if x not in codes]
        return f"Missing {len(missing)}/{code_count} codes: " + ' '.join(x[1:] for x in missing[:5]) + (" ..." if len(missing) > 5 else "")
def is_complete(codes, code_count):
    if code_count is None:
        return False
    return len(codes) >= code_count
def do_restore(codes, code_count, use_compression, use_erasure_coding):
    assert is_complete(codes, code_count)

    decoded = {k: base64.b64decode(v) for k,v in codes.items()}
    expected = sorted(expected_codes(code_count))
    normal_symbols = [decoded.get(x) for x in [x for x in expected if x.startswith(b"N")]]
    erasure_symbols = [decoded.get(x) for x in [x for x in expected if x.startswith(b"E")]]

    erasureless_restore_possible = len([x for x in normal_symbols if x is None]) == 0
    if erasureless_restore_possible or use_erasure_coding is False:
        content = b''.join(normal_symbols)
    else:
        chunk_size = max(len(x) for x in normal_symbols if x is not None) # TODO: Fails if we don't get at least one non-final normal symbol
        content = restore_erasure(normal_symbols, erasure_symbols, chunk_size)

    if use_compression is True:
        content = gzip.decompress(content)
    elif use_compression is None: # automatic determination
        try:
            content = gzip.decompress(content)
            use_compression = True
        except gzip.BadGzipFile:
            use_compression = False
    return content

def main_restore(args):
    # Default config
    restore_method = None # Should be one of: None, "webcam", "images"

    output_path = None # Should be one of: None (for use_stdout), file path
    use_stdout = False
    code_count = None # Should be one of: None (infer) or a number
    use_display = True

    expected_sha256sum = None
    use_compression = None
    use_erasure_coding = None

    # Parse command-line arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--code-count":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            code_count, args = int(args[0]), args[1:]
        elif arg == "--compress":
            use_compression = True
        elif arg == "--erasure-coding":
            use_erasure_coding = True
        elif arg == "--display":
            use_display = True
        elif arg == "--image-restore":
            restore_method = "images"
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-display":
            use_display = False
        elif arg == "--no-erasure-coding":
            use_erasure_coding = False
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--sha256":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            expected_sha256sum, args = args[0].lower(), args[1:]
            if not all(x in "0123456789abcdef" for x in expected_sha256sum):
                show_help("Not a valid SHA256: {}".format(expected_sha256sum))
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "--webcam-restore":
            restore_method = "webcam"
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)

    assert len([x for x in pargs if x == "-"]) <= 1, "stdin can be listed as an image only once"
    if restore_method is None and len(pargs) == 0 and not sys.stdin.isatty():
        logging.debug("Reading from stdin")
        restore_method = "images"
        pargs = ["-"]
    elif restore_method is None and len(pargs) == 0:
        restore_method = "webcam"
    elif restore_method is None and len(pargs) > 0:
        restore_method = "images"

    if output_path is None:
        use_stdout = True

    # Call a subprocess to do the restore
    if restore_method == "images":
        logging.info("image restore selected")
        restore_generator = image_restore(pargs)
    elif restore_method == "webcam":
        logging.info("webcam restore selected")
        restore_generator = webcam_restore(use_display=use_display)
    else:
        assert False

    # Scan codes one at a time until done
    codes = {}
    while not is_complete(codes, code_count):
        # Print status line
        if restore_method == "webcam":
            if code_count is None:
                print("Hold up QR codes to the webcam in any order.",file=sys.stderr)
            else:
                print(restore_status(codes, code_count),file=sys.stderr)

        # Read the next code as binary data
        try:
            read_code = next(restore_generator)
        except StopIteration:
            logging.fatal("Not enough codes could be read to restore the file. Exiting.")
            sys.exit(3)

        # Parse the label out
        assert b"\n" not in read_code
        code_label, content = read_code.split(b' ', maxsplit=1)
        code_num, total = code_label.split(b'/')
        total = int(total.decode('ascii'))
        if code_count is None:
            code_count = total
        elif code_count == total:
            pass
        elif code_count != total and len(codes) == 0:
            logging.fatal("Code count disagrees with --code-count option (Code={}, --code-count={})".format(code_label.decode('ascii'), code_count))
            sys.exit(4)
        elif code_count != total and len(codes) != 0:
            logging.fatal("Code count disagrees for codes: {} & {}".format(code, next(iter(code.keys()))))
            sys.exit(4)
        else:
            assert False
        assert code_count is not None
        assert code_num in expected_codes(code_count), "Unexpected code: {}".format(code_label.decode('ascii'))

        # Add the code
        if code_num in codes and codes[code_num] == content:
            logging.info(f"Read duplicate code {code_num}: IDENTICAL")
        elif code_num in codes and codes[code_num] != content:
            logging.error(f"Read duplicate code {code_num}: DIVERGES")
        elif code_num not in codes:
            logging.info(f"Read new code {code_num}")
        else:
            assert False
        codes[code_num] = content
    # Close subprocess
    # TODO: Sometimes one extra code needs to be read before it closes, fix that.
    next(restore_generator, True)

    # Do the restore
    content = do_restore(codes, code_count, use_compression=use_compression, use_erasure_coding=use_erasure_coding)

    # Check the checksum
    sha256sum = hashlib.sha256(content).hexdigest()
    exit_status = 0
    logging.info("restored sha256sum: {}".format(sha256sum))
    if expected_sha256sum is None:
        logging.debug("no expected sha256sum was given")
        print(f"sha256sum was as follows, please check against your paper backup: {sha256sum}", file=sys.stderr)
    elif expected_sha256sum == sha256sum:
        logging.debug("sha256sum matched")
        #print("File verified using sha256 checksum.", file=sys.stderr)
    elif sha256sum.startswith(expected_sha256sum):
        logging.debug("sha256sum partial matched")
        print(f"The actual sha256sum begins with checksum given on the command line, but it was not complete. The full checksum was: {sha256sum}", file=sys.stderr)
    else:
        logging.error("sha256sum did not match")
        exit_status = 4
        print(f"!!The restored file does NOT match the expected checksum. Restoring anyway.", file=sys.stderr)

    # Write the output
    if use_stdout:
        sys.stdout.buffer.write(content)
    else:
        with open(output_path, "wb") as f:
            f.write(content)
    sys.exit(exit_status)

if __name__ == "__main__":
    # parse command-line arguments
    args = sys.argv[1:]
    if len(args) > 1 and args[0] in ["-r", "--restore"]:
        main_restore(args[1:])
    else:
        main_backup(args)
